
<script type="text/javascript" src="tabletop.js"></script>
<script type="text/javascript" src="d3.min.js" charset="utf-8"></script>
<style type="text/css">
		.unselectable {
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-khtml-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			pointer-events: none;
		}
</style>
<div id="graph" style="border: 1px solid black; float: left;"></div>
<script type="text/javascript">
	window.onload = function() { init() };
	function init() {
		Tabletop.init( { key: '17ByzgRADHRfwQFjXD9vV5GnxgCH6bDBANT2g8t95m0A',
                     callback: updateGraph,
                     simpleSheet: true } )
	} 
	//Width and height
	var w=1000, h=800;
	var subGraphs = [2,2];
	var wG = w / subGraphs[1];
	var hG = h / subGraphs[0];
	var subGraphGs = [];
	var myData = [];
	var colorMap = [];
	var graphTypes = ['pie','pie','combined','none'];
	var colNames = ['date','Name','Gender','Nationality','Family History','Ethnicity','Nationality','DNA','Appearance','Personal History', 'Ancestry'];
	var plotCols = [0, 0, 1, 1, 2,2,2,2,2,2,2]; //0 if ignore, 1 if plot alone, 2 if aggregate
	var ancestryBars = [];
	var barText = [];
	//Create SVG element
	var svg = d3.select("#graph")
		.append("svg")
		.attr("width", w)
		.attr("height", h);	
	
	var toolTip = svg.append("g");//.style("visibility","hidden");

	function assignColorScales() {
		var colorList = ['#607d8b','#795548','#ff9800','#ffeb3b','#8bc34a','#009688','#dd0000','#00dd00','#0000dd','#dddd00','#dd00dd','#00dddd','#770000','#007700','#000077','#777700','#770077','#007777','#330000','#003300','#000033','#333300','#330033','#003333'];
		var colors = ["Red","Green","Orange","Yellow","Blue","Indigo","Violet"];
		var ct = 0;
		for (var i=0; i<myData.length; i++) {
			var v = Object.values(myData[i]);
			var curTotal = 0;
			for (var j=4; j<v.length; j++) { //just the 7 columns with poll data
				curTotal += Number(v[j]);
			}
			//console.log("total:",curTotal);
			for (var j=0; j<v.length; j++) {
				if (j>=4) {
					myData[i][colNames[j]] = Number(myData[i][colNames[j]]) / curTotal;}
				if (plotCols[j] > 0) {
					vv = v[j]; //ignore the first column in the data, it's a timestamp
					if (colors.indexOf(vv)==-1 && !(vv in colorMap)) {
						colorMap[vv] = colorList[ct];
						console.log(vv + "-->" + colorList[ct]);
						ct++;
						if (ct==colorList.length) {ct=0;}
					}
					else if (!(vv in colorMap)) {
						colorMap[vv] = vv;					
						console.log(vv + "-->" + colorMap[vv]);
					}
					
				}
			}
			//console.log(myData[i]);
		}
		getGraphDataCondition(-1, '');//select all data
		//console.log('colormap:', colorMap);
	}
	
	function updateGraph(data, tabletop) {
		myData = data;
		var keys = (Object.keys(data[0]));
		//var wG = (w) / (keys.length-1);
		var graphData = {};
		for (var i=0; i<subGraphs[0]; i++) {
			subGraphGs.push([]);
			var curRow = subGraphGs[i];
			for(var j=0; j<subGraphs[1]; j++) {
				var curG = svg.append("g");
				curRow.push(curG);
				if (graphTypes[i*subGraphs[1]+j] == 'bar' || graphTypes[i*subGraphs[1]+j] == 'pie') {
				svg.append("rect")
					.attr("width",wG)
					.attr("height", hG)
					.attr("x",wG*j)
					.attr("y",hG*i)
					.attr("fill","none")
					.attr("stroke","black")
					.attr("stroke-width",1);
					svg.append("rect")
						.attr("width",20)
						.attr("height", 20)
						.attr("x",wG*j+5)
						.attr("y",hG*i+5)
						.attr("data",i+","+j)
						.attr("fill","black")
						.attr("stroke","black")
						.attr("stroke-width",1)
						.on("click", function(){convertTo(d3.select(this).attr("data"),"bar");});
					svg.append("circle")
						.attr("r", 10)
						.attr("cx",wG*j+40)
						.attr("cy",hG*i+15)
						.attr("data",i+","+j)
						.attr("fill","black")
						.attr("stroke","black")
						.attr("stroke-width",1)
						.on("click", function(){convertTo(d3.select(this).attr("data"),"pie");});
				}
			}
		}
		//console.log(subGraphGs);
		setUpBars();
		assignColorScales();
		var r=0,c=0;
		for (jj=0; jj<keys.length-1; jj++) {
			if (c>=subGraphs[1]) {c=0; r++;}	
			if (graphTypes[jj] == 'bar') {console.log(r,c," bar"); plotBarGraph(r,c);}
			else if (graphTypes[jj] == 'pie') {console.log(r,c," pie"); drawPie(r,c);}
			c++;
		}
	}
	
	function getGraphData(r,c) {
		graphData = {};
		var pIndex = r*subGraphs[1]+c+1;
		var pIndex2 = 0;
		console.log("====",pIndex,plotCols);
		for (var i=0; i<plotCols.length; i++) {
			if (plotCols[i]>0) {pIndex2++;}
			if (pIndex2 == pIndex) {pIndex = i; break;}
		}
		graphData['dataIndex'] = pIndex;
		console.log("plot",r,c,pIndex,colNames[pIndex]);
		for (var i=0; i<myData.length; i++) {
			var v = Object.values(myData[i]);
			v = v[pIndex]; //ignore the first column in the data, it's a timestamp
			if (!(v in graphData)) {graphData[v] = 1; console.log(v)}
			else {graphData[v]= Number(graphData[v]) + 1;}
		}
		
		return graphData;
	}
	
	function getGraphDataCondition(condIndex,vv) {
		graphData = {};
		console.log("get condition",colNames[condIndex],vv);
		var plotAll = false;
		if (condIndex < 0) {plotAll = true; condIndex = 0;
			barText.text("All Data");}
		else {barText.text(colNames[condIndex] + ' = ' + vv);}
		var ct = 0;
		for (var i=0; i<myData.length; i++) {
			var v = Object.values(myData[i]);
			vCond = v[condIndex]; 
			if (vCond == vv || plotAll) { 
				ct++;
				for (var j=4; j<colNames.length; j++) {
					if (!(colNames[j] in graphData)) {graphData[colNames[j]] = Number(v[j]);}
					else {graphData[colNames[j]] += Number(v[j]);}
				}
			}
		}
		var maxVal = 0;
		for (var j=4; j<colNames.length; j++) {
			graphData[colNames[j]] /= ct;
			if (graphData[colNames[j]] > maxVal) {maxVal = graphData[colNames[j]];}
		}
		console.log(graphData);
		
		//plot average values
		var xG = 0*wG;
		var yG = hG; // assume r=1, c=0
		var hB = (hG - 40) / 7 - 5;
		var wB = 2*wG - 80;
		toolTip.remove();
		var curY = yG + 20;
		for (var j=4; j<colNames.length; j++) {
			var curV = Number(graphData[colNames[j]]);
			var curW = wB * curV/maxVal;
			ancestryBars[j-4].transition()
				.duration(500)
				.attr("width",curW);
			curY += hB + 5;
		}
		
		return graphData;
	}
	
	function setUpBars() {
		var xG = 0*wG;
		var yG = hG; // assume r=1, c=0
		var hB = (hG - 40) / 7 - 5;
		var wB = 2*wG - 80;
		var curY = yG + 40;
		var myContainer = subGraphGs[1][0];
		barText = myContainer.append("text")
			.text("All Data")
			.attr("x",xG + 20 + wB/2)
			.attr("y", yG+20)
			.attr("fill", "black")
			.attr("alignment-baseline","middle")
			.attr("text-anchor","middle")
			.attr("fill","black")
			.attr("font-size","22")
			.attr("font-weight","bold")
			.attr("class","unselectable");
		for (var j=4; j<colNames.length; j++) {
			myContainer.append("rect")
				.attr("width",wB)
				.attr("height", hB)
				.attr("x",xG + 20)
				.attr("y",curY)
				.attr("fill", "#DDDDDD")
				.attr("stroke","blue");
			myContainer.append("text")
				.text(colNames[j])
				.attr("x",xG + 20 + wB/2)
				.attr("y",curY + hB/2)
				.attr("fill", "black")
				.attr("alignment-baseline","middle")
				.attr("text-anchor","middle")
				.attr("fill","black")
				.attr("font-size","22")
				.attr("font-weight","bold")
				.attr("class","unselectable");
			ancestryBars[j-4] = myContainer.append("rect")
				.attr("width",0)
				.attr("height", hB)
				.attr("x",xG + 20)
				.attr("y",curY)
				.attr("fill", "rgba(0,0,0,0.25)")
				.attr("stroke","blue");
			curY += hB + 5;
		}
	}
	
	function setToolTip(ref,txt) {
		var t = 'error no tooltip found';
		try {t = toolTip.select("text").text();}
		catch(err) {//console.log(err);
		}
		//console.log(t);
		var c = [0,0];
		c = d3.mouse(ref);
		//console.log("coords:",c);
		c[0]+=5;
		c[1]-=15;
		if (t == txt && 0) { //just move it (doesn't work very well)
			toolTip.transition().duration(50)
				.attr("transform","translate("+c[0]+","+c[1]+")");	
		}
		else { //create a new one
			toolTip.remove();
			if (txt.length > 0) {
				toolTip = svg.append("g");
				var curRect = toolTip.append("rect")
					.attr("x",0)
					.attr("y",0)
					.attr("height",18)
					.attr("fill","rgba(255,255,255,0.5)")
					.style("pointer-events","none");
				var curText = toolTip.append("text")
					.text(txt)
					.attr("x",3)
					.attr("y",9)
					.attr("alignment-baseline","middle")
					.attr("text-anchor","left")
					.attr("fill","black")
					.attr("font-size","12")
					.attr("font-weight","bold")
					.attr("class","unselectable");
				var bb = curText.node().getBBox();
				//console.log(bb);
				curRect.attr("width",5+bb['width']);
				toolTip.attr("transform","translate("+c[0]+","+c[1]+")");
			}
		}
	}
	
	function convertTo(subG, type) {
		var dur = 500;
		var i = Number(subG.split(",")[0]);
		var j = Number(subG.split(",")[1]);
		console.log("clear:",i,j);
		clearG(i,j, dur);
		setTimeout(function(){convertTo2(i,j,type);},dur);
	}
	function convertTo2(i,j,type) {
		if (type == "bar") {plotBarGraph(i,j);}
		if (type == "pie") {drawPie(i,j);}
	}
	
	function clearG(i,j, dur) {
		subGraphGs[i][j].selectAll("rect").transition().duration(dur).attr("fill","white");
		subGraphGs[i][j].selectAll("path").transition().duration(dur).attr("fill","white").attr("stroke","white");
		subGraphGs[i][j].selectAll("text").transition().duration(dur).attr("fill","white");
		d3.select("#slice"+ i + j).selectAll("path")
			.transition().duration(dur).attr("fill","white").attr("stroke","white");
		setTimeout(function(){clear2(i,j);},dur);
	}
	function clear2(i,j) {
		subGraphGs[i][j].selectAll("rect").remove();
		subGraphGs[i][j].selectAll("path").remove();
		subGraphGs[i][j].selectAll("text").remove();
		subGraphGs[i][j].selectAll("g").remove();
		d3.select("#slice"+ i + j).remove();
		
	}
	
	function drawPie(rr,cc) {
		graphData = getGraphData(rr,cc);
		toolTip.remove();

		
		var xG = cc*wG;
		var yG = (rr+1)*hG;
		var x = 20 + xG;
		var totalData = 0;
		var lengthData = 0;
		for (var v in graphData) {
			if (v != 'dataIndex') {
				//if (graphData[v] > maxData) {maxData = graphData[v];}
				totalData += graphData[v];
				lengthData++;
			}
		}
		console.log("total",totalData);
		var myContainer = subGraphGs[rr][cc];
		
		myContainer.selectAll("rect").remove();
		myContainer.selectAll("path").remove();
		myContainer.selectAll("g").remove();
		myContainer.selectAll("text").remove();
		
		var cx = (x + (wG-100)/2), cy = yG - hG/2;
		var RBIG = 1.05; //ratio of large radius to small for mouseover
		var r = (Math.min(hG,wG-100) / 2 - 10)/RBIG;
		var curTh = 0;
		var sx=0,sy=0;
		var	ex = cx+Math.round(10*r*Math.sin(curTh))/10;
		var	ey = cy+Math.round(10*r*Math.cos(curTh))/10;
		var curY = cy - r;
	for (var v in graphData) {
		if (v != 'dataIndex') {
			sx = ex;
			sy = ey;
			var th = (graphData[v]/totalData) * Math.PI * 2;
			curTh += th;
			ex = cx+Math.round(10*r*Math.sin(curTh))/10;
			ey = cy+Math.round(10*r*Math.cos(curTh))/10;
			var gt50 = th > Math.PI ? 1:0;
			var cmd = 'M' + cx + "," + cy //Move pointer
			  + 'L' + sx + "," + sy
			  + 'A' + r + "," + r + ' 0 ' + gt50 + ',0 ' + ex + "," + ey
			  + 'Z';
			var sx2 = (sx-cx)*RBIG+cx, sy2 = (sy-cy)*RBIG+cy,
				ex2 = (ex-cx)*RBIG+cx, ey2 = (ey-cy)*RBIG+cy;
			var cmdBig = 'M' + cx + "," + cy //Move pointer
			  + 'L' + sx2 + "," + sy2
			  + 'A' + r*RBIG + "," + r*RBIG + ' 0 ' + gt50 + ',0 ' + ex2 + "," + ey2
			  + 'Z';
			var curG = myContainer.append("g").attr("data",v).attr("dIndex",graphData['dataIndex']);
			myContainer.append("rect")
				.attr("width",20)
				.attr("height", 20)
				.attr("x",cx+r+10)
				.attr("y",curY)
				.attr("fill","white").transition().duration(1000)
				.attr("fill", colorMap[v]);
				curY += 25;
			myContainer.append("text")
				.text(v)
				.attr("x",cx + r + 35)
				.attr("y",curY-12.5)
				.attr("alignment-baseline","middle")
				.attr("text-anchor","left")
				.attr("fill","white").transition().duration(1000)
				.attr("fill","black")
				.attr("font-size","12")
				.attr("class","unselectable");
			curG.append("path")
				.attr("d",cmd)
				.attr("data",cmdBig)
				.attr("val",graphData[v])
				.attr("fill","white")
				.attr("stroke","white").transition().duration(100)
				.attr("fill", colorMap[v]) 
				.attr("stroke","black")
				.attr("stroke-width",2);
			curG.on("mouseover", function() {
					var d = d3.select(this).selectAll("path");
					var temp = d.attr("data");
					d.attr("data",d.attr("d")).attr("d",temp).attr("stroke-width",4);
					})
				.on("mousemove", function() {
					setToolTip(this,d3.select(this).selectAll("path").attr("val"));
				})
				.on("mouseout", function() {
					var d = d3.select(this).selectAll("path");
					var temp = d.attr("data");
					d.attr("data",d.attr("d")).attr("d",temp).attr("stroke-width",2);
					toolTip.remove();
					})
				.on("click", function() {
					getGraphDataCondition(d3.select(this).attr("dIndex"),d3.select(this).attr("data"));
				});	
			}
		}
	}
	
	function plotBarGraph(r,c) {
		plotBarGraph(r,c,-1,'');
	}
	function plotBarGraph(r,c,conditionIndex,conditionValue) {
		d3.select("#slice"+ r + c).remove();
		toolTip.remove();
		var myContainer = subGraphGs[r][c];
		
		myContainer.selectAll("rect").remove();
		myContainer.selectAll("path").remove();
		myContainer.selectAll("g").remove();
		myContainer.selectAll("text").remove();
		
		if (conditionIndex >=0) {
			console.log("cI,cV",conditionIndex,conditionValue);
			var graphDataSub = getGraphDataCondition(conditionIndex,(r*subGraphs[1]+c)+1,conditionValue);
			console.log(graphDataSub);			
		}
		//set cI = 0 if current graph is 1, otherwise 1 if current graph is 0
		var conditionIndex = (r*subGraphs[1]+c)+2;
		if (conditionIndex>2) {conditionIndex=1;}
		var xG = c*wG;
		var yG = (r+1)*hG;
		var x = 20 + xG;
		graphData = getGraphData(r,c);
		var maxData = 0;
		var lengthData = 0;
		var myContainer = subGraphGs[r][c];
		var colors = ["Red","Green","Orange","Yellow","Blue","Indigo","Violet"];
		for (var v in graphData) {
			if (graphData[v] > maxData) {maxData = graphData[v];}
			lengthData++;
		}
		for (var v in graphData) {
			var curH = (hG-60)*graphData[v]/maxData;
			var curY = yG-curH-20;
			var curW = (wG-100) / lengthData - 10;
			var curRect = myContainer.append("rect")
				.attr("width",curW)
				.attr("height", 0)
				.attr("height", curH)
				.attr("x",x)
				.attr("y",curY)
				.attr("data",v)
				.attr("val",graphData[v])
				.on("mouseout", function() {
					var d = d3.select(this).transition().duration(1000).style("fill","grey");
					toolTip.remove();
					})
				.on("mousemove", function() {
					setToolTip(this,d3.select(this).attr("val"));
				})
				.on("click", function() {
					plotBarGraph(r,c,conditionIndex,d3.select(this).attr("data"));
				});
			if (colors.indexOf(v)>-1) {
				curRect.attr("data",v)
				.on("mouseover", function() {
					var t = d3.select(this);
					t.transition()
						.style("fill",t.attr("data"));
					});}
			else {
				curRect.on("mouseover", function() {
					var t = d3.select(this);
					t.transition().duration(10)
						.style("fill",colorMap[t.attr("data")]);
					});}
			curRect.attr("fill","white")//.transition().duration(10)
				.attr("fill","grey");	
			if (v==conditionValue) { 
				var subG = svg.append("g");
				subG.attr("id","slice" + r + c);
				var totalDataSub = 0;
				for (var vv in graphDataSub) {
					totalDataSub += graphDataSub[vv];
				}
				var yy = curY;
				for (var vv in graphDataSub) {
					console.log(vv,curH*graphDataSub[vv]/totalDataSub);
					subG.append("rect")
						.attr("width",0.8*curW)
						.attr("height", curH*graphDataSub[vv]/totalDataSub)
						.attr("x",x + 0.1*curW)
						.attr("y",yy)
						.attr("data",v)
						.attr("val",vv + ":" + graphDataSub[vv])
						.attr("fill", colorMap[vv]);
					yy += curH*graphDataSub[vv]/totalDataSub;
				}
				subG.on("mousemove", function() {
					var tt="";
					d3.select(this).selectAll("rect").each(function (d) {
						if (tt.length>0) {tt+=", ";}
						tt += d3.select(this).attr("val");
					});
					setToolTip(this,tt);
				})
				.on("click", function () {
					plotBarGraph(r,c,-1,'');
				});
			}
			myContainer.append("text")
				.text(v)
				.attr("x",x+curW/2)
				.attr("y",yG-10)
				.attr("alignment-baseline","middle")
				.attr("text-anchor","middle")
				.attr("fill","white")//.transition().duration(1000)
				.attr("fill","black")
				.attr("font-size","12")
				.attr("class","unselectable");
			x+=curW+10;
		}
	}
</script>
